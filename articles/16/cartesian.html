<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Subsets and Cartesian Products</title>
  <meta name="description" content="Computing subsets and Cartesian products  are common tasks you are faced with when trying to solve problems by computer programming. And common advice you ge...">


  <link rel="stylesheet" href="/css/tufte.css">	
  

  <!-- Google Fonts loaded here -->
  <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>

  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  <link rel="canonical" href="/articles/16/cartesian">
  <link rel="alternate" type="application/rss+xml" title="The Proof Chef" href="/feed.xml" />
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <nav class="group">
		<a href="/"><img class="badge" src="/assets/img/lambda-parens-logo.jpg" alt="New"></a>
		<a href="/">Notebook</a>
		<a href="/page">Books and Articles</a>
		<a href="/page/code.html">Code</a>
		<a href="/about">About Tedszy</a>
	</nav>
</header>

    <article>
      <h1>Subsets and cartesian products</h1>
<p>September 15, 2016</p>


<p><span class="newthought">Computing subsets and Cartesian products</span>  are common 
tasks you are faced with when trying to solve problems by computer 
programming. And common advice you get is to do these things by 
recursion or, in the case of Cartesian products, by Lisp macros.
But we don’t want to do them that way.</p>

<h4 id="1-subsets">1. Subsets</h4>

<p>A typical Scheme formula for computing subsets uses recursion. But
suppose you are looking for something among the subsets of a large
set. What if you have billions of subsets and you want to iterate over
them one at a time? Well forget the usual recursive solutions. We are
going to use bit-hacking on integers.</p>

<p>Every subset of a set can be represented by a binary code. For 
example consider the set <code class="highlighter-rouge">{A,B,C,D,E}</code>. If we set <code class="highlighter-rouge">0</code> to
mean “don’t choose the element” and <code class="highlighter-rouge">1</code> to mean “choose the
element”, then the subset <code class="highlighter-rouge">{A,C,E}</code> can be represented
by the binary code <code class="highlighter-rouge">10101</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A B C D E
1`0 1 0 1
---------
A   C   E
</code></pre></div></div>

<p>This leads to a good idea! If we take any integer less than <code class="highlighter-rouge">2^5</code>
and we extract the bits using arithmetic right shift, we can decode
which elements are chosen for the subset and which are rejected.
Looping through all such numbers gives us all possible subsets.</p>

<div class="language-cl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">subsets</span> <span class="p">(</span><span class="nv">myset</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">k</span> <span class="nv">from</span> <span class="mi">0</span> <span class="nv">below</span> <span class="p">(</span><span class="nb">expt</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">myset</span><span class="p">))</span>
     <span class="nv">collecting</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">s</span> <span class="nv">in</span> <span class="nv">myset</span>
		   <span class="nv">with</span> <span class="nv">subset</span> <span class="nb">=</span> <span class="no">nil</span>
		   <span class="nv">with</span> <span class="nv">bitfield</span> <span class="nb">=</span> <span class="nv">k</span>
		   <span class="nb">do</span> <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">logand</span> <span class="nv">bitfield</span> <span class="mi">1</span><span class="p">))</span>
			<span class="p">(</span><span class="nb">push</span> <span class="nv">s</span> <span class="nv">subset</span><span class="p">))</span>
		     <span class="p">(</span><span class="nb">setf</span> <span class="nv">bitfield</span> <span class="p">(</span><span class="nb">ash</span> <span class="nv">bitfield</span> <span class="mi">-1</span><span class="p">))</span>
		   <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="nv">subset</span><span class="p">))))</span>
</code></pre></div></div>

<p>We test if the last bit is 1 by doing bitwise-<code class="highlighter-rouge">and</code> with 1. Then we 
right-shift to get the next bit, and so on. We know that there will 
be <code class="highlighter-rouge">2^n</code> subsets, so we know when to stop. This way of doing it 
allows some easy modifications. For instance, if you don’t want the 
empty set, just start iterating from <code class="highlighter-rouge">k=1</code> instead of <code class="highlighter-rouge">k=0.</code> What 
could possibly be easier than this? No need for mind-bending 
inefficient recursion. Illustration:</p>

<div class="language-cl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">subsets</span> <span class="o">'</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">NIL</span> <span class="p">(</span><span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="nv">B</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">A</span><span class="p">)</span> 
<span class="p">(</span><span class="nv">D</span> <span class="nv">B</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">C</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">C</span> <span class="nv">B</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">))</span>
</code></pre></div></div>

<h4 id="2-cartesian-products">2. Cartesian Products</h4>

<p>Suppose we have three lists of number <code class="highlighter-rouge">(2 3 5)</code>, <code class="highlighter-rouge">(7 11 13)</code> 
and <code class="highlighter-rouge">(17 19 23).</code> We want to form all possible products obtained by 
choosing one number from each list. No problem, you say, you’ll just 
use nested loops, one loop for each list. But that works only if you 
know you will have exactly three lists of numbers. What if you have
<code class="highlighter-rouge">n</code> lists of numbers? Then what? Recursion? I’ve seen it done that 
way. Macros? Yes, incredible as it sounds, I’ve seen macros that 
generate <code class="highlighter-rouge">n</code> nested loops to do this job.</p>

<p>But none of such things are necessary when there exists a perfectly 
good functional programming idiom tailor-made for these kind of 
jobs: <code class="highlighter-rouge">reduce</code>!</p>

<div class="language-cl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">cartesian</span> <span class="p">(</span><span class="nv">list-of-lists</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">reduce</span> <span class="nf">#'</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">u</span> <span class="nv">v</span><span class="p">)</span>
	      <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">i</span> <span class="nv">in</span> <span class="nv">u</span> 
                 <span class="nb">nconc</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">j</span> <span class="nv">in</span> <span class="nv">v</span> <span class="nv">collect</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">))))</span>
	  <span class="nv">list-of-lists</span><span class="p">))</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">lambda</code> function takes two lists and does a Cartesian product,
concatenating all the results into one big list. Further Cartesian 
products are accumulated into this list by <code class="highlighter-rouge">reduce</code> as it traverses 
down the <code class="highlighter-rouge">list-of-lists.</code> There, a simple functional way 
of doing it. Illustration:</p>

<div class="language-cl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">&gt;</span><span class="p">(</span><span class="nv">cartesian</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">11</span> <span class="mi">13</span><span class="p">)</span> <span class="p">(</span><span class="mi">17</span> <span class="mi">19</span> <span class="mi">23</span><span class="p">)))</span>
<span class="p">(</span><span class="mi">238</span> <span class="mi">266</span> <span class="mi">322</span> <span class="mi">374</span> <span class="mi">418</span> <span class="mi">506</span> <span class="mi">442</span> <span class="mi">494</span> <span class="mi">598</span> <span class="mi">357</span> <span class="mi">399</span> <span class="mi">483</span> <span class="mi">561</span> <span class="mi">627</span> 
 <span class="mi">759</span> <span class="mi">663</span> <span class="mi">741</span> <span class="mi">897</span> <span class="mi">595</span> <span class="mi">665</span> <span class="mi">805</span> <span class="mi">935</span> <span class="mi">1045</span> <span class="mi">1265</span> <span class="mi">1105</span> <span class="mi">1235</span> <span class="mi">1495</span><span class="p">)</span>
</code></pre></div></div>

<p>A example of an application for Cartesian product is to compute 
all the divisors of a number when the prime factorization is known.</p>




    </article>
    <span class="print-footer">Subsets and Cartesian Products - September 15, 2016 - Ted Szylowiec</span>
    <footer>
  <ul class="footer-links group">
   <!-- 
   <li><a href="mailto:hate@spam.net"><span class="icon-mail"></span></a></li>    
   -->
    
      <li>
        <a href="//github.com/tedszy"><span class="icon-github"></span></a>
      </li>
      
  </ul>
<div class="credits">
<span>&copy; 2018 &nbsp;&nbsp;TED SZYLOWIEC</span></br> 
<span>This site created with the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme for Mathematics Teaching </a> in <a href="//jekyllrb.com">Jekyll</a>.</span> 
</div>  
</footer>

  </body>
</html>
